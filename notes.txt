Ce qui est important pour définir une pièce est la notion
d'opposé.

Gauche opposé à Droite
ET
Haut opposé à Bas

Une pièce est composée de 4 emplacements (HAUT, BAS, GAUCHE, DROITE),
et chaque emplacement contient un chiffre compris entre 1 et 9.

Deux pièces sont emboitables si.. 
    p1.gauche == p2.droite => p1 à droite de p2 
    OU
    p1.droite == p2.gauche => p1 à gauche de p2
    OU 
    p1.haut == p2.bas => p1 en bas de p2
    OU
    p1.bas == p2.haut => p1 en haut de p2

Un plateau est composé de n*n pièce où correspond à la dimension
du plateau (3x3, 4x4, ..)

Pour l'algo de backtracking, ça prend la forme d'un arbre où on explore
chaque combinaison et on enlève les branches qui n'aboutissent pas.
Chaque noeud représentera une configuration de plateau (différente).
La noeud source sera donc le plateau vide, puis on ajoute des pièces
tant que ça fonctionne, et si ça fonctionne pas pour une pièce on en essaie
une autre (en remontant la branche et créer une sous-branche supplémentaire)

Un plateau aura les méthodes suivantes :
-calculateOutcome qui calcule si le plateau est insauvable, sauvable ou complété.
-createChild qui créé un noeud fils avec une configuration potentiellement complète
à partir de la configuration du noeud parent.
-parent qui retourne le noeud parent

__________________________________


In order to apply backtracking to a specific class of problems, one must provide the 
data P for the particular instance of the problem that is to be solved, and 
six procedural parameters, root, reject, accept, first, next, and output. 
These procedures should take the instance data P as a parameter and should do the 
following:

    root(P): return the partial candidate at the root of the search tree.
    reject(P,c): return true only if the partial candidate c is not worth completing.
    accept(P,c): return true if c is a solution of P, and false otherwise.
    first(P,c): generate the first extension of candidate c.
    next(P,s): generate the next alternative extension of a candidate, 
        after the extension s.
    output(P,c): use the solution c of P, as appropriate to the application.

The backtracking algorithm reduces the problem to the call bt(root(P)), 
where bt is the following recursive procedure: 

procedure bt(c) is
    if reject(P, c) then return         
    if accept(P, c) then output(P, c)   
    s ← first(P, c)                                         
    while s ≠ NULL do
        bt(s)                           
        s ← next(P, s)                  


P : Arbre de recherche dont le root est représenté par un plateau vide
c : Plateau candidat, toujours issu d'un autre Plateau (Plateau parent dans l'arbre)
s : Extension d'un candidat, c'est à dire un candidat + sa descendance (branche de l'arbre)

Je décide de partir sur une implémentation itérative avec une stack car 
l'algo ne peut être implémentée en une fonction "tail-recursive". De ce fait le 
compilateur ne pourra pas optimiser le code.

procedure bt(c) is
    if reject(P, c) then return         //on backtrack
    if accept(P, c) then output(P, c)   //on retourne le candidat validé
    s ← first(P, c)                     //on génère l'extension                     
    while s ≠ NULL do
        bt(s)                           //on explore plus en profondeur..
        s ← next(P, s)                  //..jqa ce qu'il n'y ait plus de possibilités


On stocke dans la stack chaque instance de plateau potentiellement succès.
Un predecesseur (parent) et potentiellement plusieurs successeurs (children)

Dans un Plateau on a les pièces placées dans la grille + les pièces non placées.

__________________________________


int main()
{
    //on a un certains nombres de pièces en input
    TetravexSolver(int dim, vector<Piece>)
    solver = TetravexSolver.create(std::string nomFichier)

    //on print le Plateau résultat ('<<' override)
    std::cout<<solver.solve()<<std::endl;

    return 0;
}


Tile : structure de données attributs up, down, left, right (unsigned short).

Board : classe avec une grille de Tiles placées (initialement vide)
et un ensemble de Tiles non placées dans un stack (initialement pleine).
Pointeur vers predecesseur.
Contient également des méthodes pour calculer l'outcome, générer fils, accéder parent,..


__________________________________


On devrait plutot séparer l'entité plateau de pièces tetravex et l'arbre avec
la notion de node fils, parent,..

C'est le TetravexSolver qui gére l'arbre de Plateaux, la stack, qui génére
les Plateaux fils, etc..



->Ajouter à la classe Plateau de quoi move un Tile de unused vers la grid,
vérifier si le move est valide, etc..


__________________________________


On pourrait dire qu'un TileValue c'est la struct avec les haut, bas, gauche, droite
et que la struct Tile contient une TileValue avec l'indexGrid qui indique
sa position dans la grid, -1 dans le cas où il n'est pas utilisé.



!!IMPORTANT!!
On rappelle que le but de la génération de l'arbre est de BOURRER
jusqu'à ce que ça soit cassé ou rempli ou résolu.
Donc pas besoin de méthode pour retirer une pièce du plateau, uniquement
pour ajouter comme un singe.



Il faut régler le print, le addTileToGrid est dégueulasse avec plein de if.
