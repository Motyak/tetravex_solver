Ce qui est important pour définir une pièce est la notion
d'opposé.

Gauche opposé à Droite
ET
Haut opposé à Bas

Une pièce est composée de 4 emplacements (HAUT, BAS, GAUCHE, DROITE),
et chaque emplacement contient un chiffre compris entre 1 et 9.

Deux pièces sont emboitables si.. 
    p1.gauche == p2.droite => p1 à droite de p2 
    OU
    p1.droite == p2.gauche => p1 à gauche de p2
    OU 
    p1.haut == p2.bas => p1 en bas de p2
    OU
    p1.bas == p2.haut => p1 en haut de p2

Un plateau est composé de n*n pièce où correspond à la dimension
du plateau (3x3, 4x4, ..)

Pour l'algo de backtracking, ça prend la forme d'un arbre où on explore
chaque combinaison et on enlève les branches qui n'aboutissent pas.
Chaque noeud représentera une configuration de plateau (différente).
La noeud source sera donc le plateau vide, puis on ajoute des pièces
tant que ça fonctionne, et si ça fonctionne pas pour une pièce on en essaie
une autre (en remontant la branche et créer une sous-branche supplémentaire)

Un plateau aura les méthodes suivantes :
-calculateOutcome qui calcule si le plateau est insauvable, sauvable ou complété.
-createChild qui créé un noeud fils avec une configuration potentiellement complète
à partir de la configuration du noeud parent.
-parent qui retourne le noeud parent

__________________________________


In order to apply backtracking to a specific class of problems, one must provide the 
data P for the particular instance of the problem that is to be solved, and 
six procedural parameters, root, reject, accept, first, next, and output. 
These procedures should take the instance data P as a parameter and should do the 
following:

    root(P): return the partial candidate at the root of the search tree.
    reject(P,c): return true only if the partial candidate c is not worth completing.
    accept(P,c): return true if c is a solution of P, and false otherwise.
    first(P,c): generate the first extension of candidate c.
    next(P,s): generate the next alternative extension of a candidate, 
        after the extension s.
    output(P,c): use the solution c of P, as appropriate to the application.

The backtracking algorithm reduces the problem to the call bt(root(P)), 
where bt is the following recursive procedure: 

procedure bt(c) is
    if reject(P, c) then return         
    if accept(P, c) then output(P, c)   
    s ← first(P, c)                                         
    while s ≠ NULL do
        bt(s)                           
        s ← next(P, s)                  


P : Arbre de recherche dont le root est représenté par un plateau vide
c : Plateau candidat, toujours issu d'un autre Plateau (Plateau parent dans l'arbre)
s : Extension d'un candidat, c'est à dire un candidat + sa descendance (branche de l'arbre)

Je décide de partir sur une implémentation itérative avec une stack car 
l'algo ne peut être implémentée en une fonction "tail-recursive". De ce fait le 
compilateur ne pourra pas optimiser le code.

procedure bt(c) is
    if reject(P, c) then return         //on backtrack
    if accept(P, c) then output(P, c)   //on retourne le candidat validé
    s ← first(P, c)                     //on génère l'extension                     
    while s ≠ NULL do
        bt(s)                           //on explore plus en profondeur..
        s ← next(P, s)                  //..jqa ce qu'il n'y ait plus de possibilités


On stocke dans la stack chaque instance de plateau potentiellement succès.
Un predecesseur (parent) et potentiellement plusieurs successeurs (children)

Dans un Plateau on a les pièces placées dans la grille + les pièces non placées.

__________________________________


int main()
{
    //on a un certains nombres de pièces en input
    TetravexSolver(int dim, vector<Piece>)
    solver = TetravexSolver.create(std::string nomFichier)

    //on print le Plateau résultat ('<<' override)
    std::cout<<solver.solve()<<std::endl;

    return 0;
}


Tile : structure de données attributs up, down, left, right (unsigned short).

Board : classe avec une grille de Tiles placées (initialement vide)
et un ensemble de Tiles non placées dans un stack (initialement pleine).
Pointeur vers predecesseur.
Contient également des méthodes pour calculer l'outcome, générer fils, accéder parent,..


__________________________________


On devrait plutot séparer l'entité plateau de pièces tetravex et l'arbre avec
la notion de node fils, parent,..

C'est le TetravexSolver qui gére l'arbre de Plateaux, la stack, qui génére
les Plateaux fils, etc..



->Ajouter à la classe Plateau de quoi move un Tile de unused vers la grid,
vérifier si le move est valide, etc..


__________________________________


On pourrait dire qu'un TileValue c'est la struct avec les haut, bas, gauche, droite
et que la struct Tile contient une TileValue avec l'indexGrid qui indique
sa position dans la grid, -1 dans le cas où il n'est pas utilisé.



!!IMPORTANT!!
On rappelle que le but de la génération de l'arbre est de BOURRER
jusqu'à ce que ça soit cassé ou rempli ou résolu.
Donc pas besoin de méthode pour retirer une pièce du plateau, uniquement
pour ajouter comme un singe.



Il faut régler le print, le addTileToGrid est dégueulasse avec plein de if.

Utiliser des pointeurs bordel de merde, 
on fait un vector pour ce qui est unused et un vector
pour la grid. Emplacement vide si valeur nullptr. MERDE.




__________________________________


On va dire qu'un Tile c'est une structure de int avec les valeurs d'un Tile.
Un Board c'est un alias vers un std::vector<Tile*>.
Dans Solver on a : 
-un std::vector<Tile*>* qui représente les Tiles (configuration)
-un Board* qui représente le currentBoard (<=>tmp)
-une std::stack<Board*> qui permet de construire l'arbre et d'appliquer le backtracking

Dans board on a :
-std::vector<Tile*> pour les Tiles placées.
-std::stack<int> pour les emplacements libres restants sur le board

__________________________________

Pour la méthode tileCanBePlaced, d'abord mettre tous les checks dans le même corps,
puis on essai d'opti et eventuellement on sépare en sous-méthodes privées.

Logger la progression de l'arbre (tentative 0->1 par exemple.. ou alors juste
l'étage donc 0) 

_______________________________

PB : trop de mémoires consommés, trop de boards créés, met trop de temps
à trouver le 5x5 (alors que 3x3 rapide).

L'exemple 4x4 nécessite 1050313 plateaux générés avant de trouver la solution.
L'exemple 3x3 nécessite 167 plateaux (fait en 0.024s).




Idées pour résoudre le pb de mémoire :
-Stocker les pointeurs vers les Boards fils (récursif), 
lorsqu'on ajoute un fils a un board, on l'ajoute également à tous les
parents/successeurs du board à qui on ajoute le fils.
Lorsqu'un board mène vers une dead end, il s'enlève des fils de tous ses
parents puis se désalloue s'il n'a plus de fils.
Si un board mène vers une dead end et qu'il n'a plus de fils, il se
désalloue.

EN GROS, quand un board mène vers une deadend, avant de désallouer le board 
en question, il faut vérifier si on peut désallouer son parent récursivement.
En gros, on peut désallouer le parent s'il n'a que lui comme fils.
Du coup il faut remontrer jusqu'en haut de la branche pour désallouer tous les
boards qui n'ont plus de raison d'exister.


Stratégie pour désallouer la mémoire récursivement au fur et à mesure que
des branches se ferment :
Lorsqu'on ne trouve aucun board candidat à ajouter à la stack, c'est à dire
lorsqu'on rencontre une dead end, on désalloue récursivement les plateaux
qui n'ont plus de raison d'exister.
Il faut que chaque board ait un pointeur vers son parent, ainsi qu'un nombre de 
fils.
Exemple : '2->1' mène vers une dead end, du coup je stocke temporairement
l'adresse de son parent avant de le désallouer (le fils). 
Puis j'enlève le fils, désalloué, du nombre de fils du parent.
Si le parent n'a plus de raison d'exister (dead end car plus aucun fils),
alors on stocke temporairement son parent avant de le désallouer, etc.....

Je vais peut etre devoir utiliser des shared_ptr car lorsque je vais désallouer
le parent d'un board, il va falloir que j'affecte la valeur nullptr non seulement
au pointeur du parent, contenu dans le fils, mais aussi au pointeur du parent qui
se trouve encore dans la stack (sinon ca pointe vers espace désalloué).
Du coup je pars du principe qu'il est possible d'un stack.top() soit nullptr, 
donc si c'est le cas on récupère le prochain stack.top() (après un pop()).

Le PB c'est que si on désalloue currentBoard pendant la boucle for (pour push
des candidats potentiels dans la stack), bah du coup je peux plus faire de vérif
de tileToPlace parce qu'il est null.

=> Au final pas eu besoin



Mettre un pointeur vers un std::vector<std::shared_ptr<Board>>> plutot
que d'avoir un vector avec les memes pointeurs partout dans chaque board.